\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}
\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{enumerate}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\setlength{\parindent}{0pt}  

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\footnotesize \parbox{11cm}{Return Oriented Programming Survey} }
\rhead{\footnotesize \parbox{11cm}{ } }

\title{Return Oriented Programming Survey}
\author{Michael Patrick O'Connor, Johnathan Michael Smith}
\date{}

\begin{document}
\maketitle

\newpage
\section*{Introduction}
This paper will review, in part, the history of Return Oriented Programming (ROP).  It will explore some technical reasons that made ROP a viable attack methodology. This paper will also explore the foundational elements of ROP, and the ways those foundational elements are used to attack vulnerable systems.  After the review of ROP we will review ROP mitigation techniques.  From ISA mitigation techniques, to mitigation techniques deployed in programming languages. This paper will then take a look at some current extensions to ROP, such as Jump Oriented Programming (JOP), and look at possible ways they can be used in the future.
\section*{History of ROP}
\subsection*{Stack Smashing Mitigation Work Arounds}
From the classic stack smashing attack, obligatory Aleph One reference, of placing attack code to be executed in memory came a technique called Write XOR Execute, $W \oplus X$. This protection prevents any code not marked as executable to the operating system from being executed, so any code to be executed in the memory section would fail. A way around this technique would be to execute code that was already created and marked as executable, this became the basis for Return to Libc attacks.
\subsection*{Return to Libc}
Return to Libc is a class of attack that use stack smashing techniques to overwrite the stack pointer other values and to have arbritary functions from libc, or any viable library. Since the code in a standard library is marked as executable from the OS if an attacker moves control of an attacked program to it it will execute. In this way an attacker could perform any library function available to the attacked program. After performing one library function an attacker can then jump to an other function to perform a set of commands.
\subsection*{Return Oriented Programming}
From return-into-libc attacks there is the generalization of the attack termed Return Oriented Programming (ROP).  This generalized form of return-into-libc attacks is based on the idea of gadgets.  Gadgets are small pieces of code that perform an actiivty, i.e. addition, memory store, etc., and end with a return statement.  The goal of the gadgets is to create a turing complete set of activities that can then be used to perform arbriratrary execution and allow an attacker more freedom than would be provided by return-into-libc attacks.
\section*{Description of ROP}
The difference between ROP and a standard control flow attack is that the stack pointer is used to move from one code segment to the next as opposed to the standard instruction pointer.  In ROP the idea is to use code segments that end in a ret statement
The basis for these code segments are genearlly referred to as gadgets, and all end in return instructions (hence Return Oriented Programming).  These gadgets are generally constructed from a library, either by hand or "compiler," to provide a turning complete set of actions. For this a general principal is to construct a gadget suite of mathmatical and logical operations, set and get from memory, branch, and compare actions.  From this set an attacker can create arbrirtary code execution for a ROP attack and get more functionality than from standard return-into-libc attacks.
\section*{Mitigation Techniques for ROP}
There a number of mitigation tecniques from the hardware upto the software level.  This paper will take a brief look at hardware, operating system, and code design techniques that can help mitigate ROP attacks.  It will also look at the pluses and minuses of these techniques.
\subsection*{Hardware}
At the hardware level Instruction Set Architecture (ISA) randomization would a very effective way to prevent ROP attacks.  ROP attacks rely on jumping into exact portions of a library and expecting that [ASSEMBLY CODE] will execute a given gadget.  If the ISA did not perform the same action with the same assembly code fragments then ROP attacks would become much harder.  An attacker would either need to make an attack code for each randomization of a given ISA and bombard it with a vulnerable program with each variation or an attacker would need to hope that the one version created would work.  ISA randomization would mean reworking of many levels of the computer stack and would need to be pushed across all the systems to be affective. this makes it very difficult to envision being used in the real world.
\subsection*{Operating System}
There are many standard attack mitigation techniques that will help against ROP attacks; Control Flow Graphs that don't allow a program to act in ways that are counter to its predetermined control flow.  CFGs are difficult to implement for several reasons, one being overhead.  Every time a branch, jump, return, etc. is used a check needs to be made, it would also need to be done for all previously created programs to have any use, making full CFGs as an attack mittigation technique difficult currently. Shadow stacks that protect the stack pointer from being over ridden, though an attacker could "simply" smash both the normal and shadow stacks.  
A prime ROP mitigation technique is to check, in a way, the frequency of ret instructions for a running program.  Now it is likely that in any given program there will be a section of code where there are many frequent ret instructions.  Techniques that look for this type of activity therefore set thresholds to determine if an attack is happening, the threshold looks for the average amount of instructions between ret instructions.  In this way it can be determined, to an acceptable degree, that a ROP attack has been usstained and steps can be taken.
\subsection*{Code Design}
From the code design level the mitigation techniques deployed against other attacks can be used to prevent ROP attacks too. Simple steps such as preventing buffer overflows and memory leaks are "easy" ways to frustrate attackers.  Sanitizing input to prevent information leaks from attacks is a smart way to make it more difficult for attackers to accquire the information they need to start attacks, ROP or otherwise.  When using memory safe languages, i.e. Java, reduce the amount of just in time (JIT) compiled code, to again reduce the locations for attackers to maliciously enter your code.
In terms of ROP specific design decisions to mitigate attacks a simple, if not overly effective, tactic is only include the minimum amount of packages necessary.  This will deprive ROP attackers the breadth of potential gadget options which will make creating an attack more difficult.  ROP attacks do not necessarily need to use a library but can use just the available program executable code, which we will explain in the next section.  In this regard homoginzed code and and a compiler that does not use the most esoteric ISA options will provide less chances for ROP attacks to use the density of code to their advantage.
\section*{Extensions of ROP}
ROP as a programming technique is already growing in depth and breadth.  The most basic extension to ROP is to create the gadgets and a derived program in an automated manner.  First an attacker could create, or accquire, a method to generate gadgets from a given executable.  From this an attacker could then wirte a program in their language of choice and compile it into an attack package from the gadgets generated.
Another, obvious once someone smart figures it out first, extension is Jump Oriented Programming (JOP).  This way instead of using rets and the stack pointer to move through attack code jmp instructions are used.  Attacks using this method have more variety simply from the basis that there is more variety in jmp instructions; far, near, direct, and indirect.  Using jmp instructions does cause an issue however, they are not as readily available in standard libraries as ret instructions and therefore it is harder to construct a turing complete set of gadgets and from there a viable JOP attack payload.
A would be attacker can also use ROP but not from a standard library linked with an executable, but an executable itself. Large professional applications contain dense code sets that can be exploited in, almost, the same fashion as libc.  However, these applications do not normally have the depth of standard library calls and therefore might not to use some gadgets created from libraries to be fully turing complete.  This type of attack is a useful extension of ROP since it might be feasible to prevent an attacker from using a standard library in but without complete control flow graphs it would be very difficult to prevent a program from executing code within its own executable for an attack.
\section*{Conclusion}
ROP is a robust way to attack a system
It is not easily stoppable and is easily extensible
It is growing even today
\end{document}
