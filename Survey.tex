\documentclass[11pt]{amsart}
\usepackage{geometry}        % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}
\usepackage[parfill]{parskip}  % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{enumerate}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\setlength{\parindent}{0pt} 

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\footnotesize \parbox{11cm}{Return Oriented Programming Survey} }
\rhead{\footnotesize \parbox{11cm}{ } }

\title{Return Oriented Programming Survey}
\author{Michael Patrick O'Connor, Johnathan Michael Smith}
\date{}

\begin{document}
\maketitle

\newpage
\section*{Introduction}
This paper will review, in part, the history of Return Oriented Programming (ROP). It will explore some technical reasons that made ROP a viable attack methodology. This paper will also explore the foundational elements of ROP, and the ways those foundational elements are used to attack vulnerable systems. After the review of ROP we will review ROP mitigation techniques. From ISA mitigation techniques, to mitigation techniques deployed in programming languages. This paper will then take a look at some current extensions to ROP, such as Jump Oriented Programming (JOP), and look at possible ways they can be used in the future.
\section*{History of ROP}
As always, to understand where we are we need to see where we have been.  This will be a brief description of how the security community came to ROP, there are fuller details but this out of scope for this paper.  This paper will start with Aleph One.
\subsection*{Stack Smashing Mitigation Work Arounds}
From the classic stack smashing attack, obligatory Aleph One reference, of placing attack code to be executed in memory came a technique called Write XOR Execute, $W \oplus X$. This protection prevents any code not marked as executable to the operating system from being executed, so any code to be executed in the memory section would fail. A way around this technique would be to execute code that was already created and marked as executable, effectively side stepping the whole purpose of $W \oplus X$.  These type of attacks are termed Code Reuse Attacks.
\subsection*{Code Reuse Attacks}
Code Reuse Attacks are attacks that use code already existing in the target system to work as the payload. Return-into-libc is an example of code reuse attacks that uses the libc library as the existing code to work in. Libc is a package of standard libraries that are defined on most operating systems and is full of useful methods to attacks. Return-into-libc attacks proceed in the following fashion, an attacker takes control of the instruction flow, either by stack smashing or any other technique, and directs the program perform arbritary functions from libc. Since the code in a standard library is marked as executable from the OS if an attacker moves control of an attacked program to it it will execute. In this way an attacker could perform any library function available to the attacked program with values of their choosing. After performing one library function an attacker can then jump to an other function to perform a complex payload.  From return-into-libc attacks we then got the generalization known as ROP.
\section*{Description of Return Oriented Programming}
ROP is a generalization and extension of return-into-libc. This form of code reuse attacks is based on the idea of using of small pieces of code termed gadgets to create payloads. Gadgets are small pieces of code that perform an actiivty, i.e. addition, memory store, etc., and end with a return statement. The goal of the gadgets is to create a turing complete set of activities that can then be used to perform arbriratrary execution and allow an attacker more freedom than would be provided by return-into-libc attacks. ROP is a generalization and extension of code reuse attacks, i.e. The difference between ROP and a standard control flow attack is that the stack pointer is used to move from one code segment to the next as opposed to the standard instruction pointer. In ROP the idea is to use code segments that end in a ret statement.\newline
The basis for these code segments are genearlly referred to as gadgets, and all end in return instructions (hence Return Oriented Programming). These gadgets are generally constructed from a library, either by hand or "compiler," to provide a turning complete set of actions. For this a general principal is to construct a gadget suite of mathmatical and logical operations, set and get from memory, branch, and compare actions. From this set an attacker can create arbrirtary code execution for a ROP attack and get more functionality than from standard return-into-libc attacks.
\section*{Mitigation Techniques for ROP}
There a number of mitigation tecniques from the hardware upto the software level. This paper will take a brief look at hardware, operating system, and code design techniques that can help mitigate ROP attacks. It will also look at the pluses and minuses of these techniques.
\subsection*{Hardware}
At the hardware level Instruction Set Architecture (ISA) randomization would a very effective way to prevent ROP attacks. ROP attacks rely on jumping into exact portions of a library and expecting that [ASSEMBLY CODE] will execute a given gadget. If the ISA did not perform the same action with the same assembly code fragments then ROP attacks would become much harder. An attacker would either need to make an attack code for each randomization of a given ISA and bombard it with a vulnerable program with each variation or an attacker would need to hope that the one version created would work. ISA randomization would mean reworking of many levels of the computer stack and would need to be pushed across all the systems to be affective. this makes it very difficult to envision being used in the real world.
\subsection*{Operating System}
There are many standard attack mitigation techniques that will help against ROP attacks; Control Flow Integrity enforcement that don't allow a program to act in ways that are counter to its predetermined control flow. CFI is difficult to implement for several reasons, one being overhead. Every time a branch, jump, return, etc. is used a check needs to be made, it would also need to be done for all previously created programs to have any use, making full CFI as an attack mittigation technique difficult currently. Shadow stacks that protect the stack pointer from being over ridden, though an attacker could "simply" smash both the normal and shadow stacks. \newline
A prime ROP mitigation technique is to check, in a way, the frequency of ret instructions for a running program. Now it is likely that in any given program there will be a section of code where there are many frequent ret instructions. Techniques that look for this type of activity therefore set thresholds to determine if an attack is happening, the threshold looks for the average amount of instructions between ret instructions. In this way it can be determined, to an acceptable degree, that a ROP attack has been usstained and steps can be taken.
\subsection*{Code Design}
From the code design level the mitigation techniques deployed against other attacks can be used to prevent ROP attacks too. Simple steps such as preventing buffer overflows and memory leaks are "easy" ways to frustrate attackers. Sanitizing input to prevent information leaks from attacks is a smart way to make it more difficult for attackers to accquire the information they need to start attacks, ROP or otherwise. When using memory safe languages, i.e. Java, reduce the amount of just in time (JIT) compiled code, to again reduce the locations for attackers to maliciously enter your code.\newline
In terms of ROP specific design decisions to mitigate attacks a simple, if not overly effective, tactic is only include the minimum amount of packages necessary. This will deprive ROP attackers the breadth of potential gadget options which will make creating an attack more difficult. ROP attacks do not necessarily need to use a library but can use just the available program executable code, which we will explain in the next section. In this regard homoginzed code and and a compiler that does not use the most esoteric ISA options will provide less chances for ROP attacks to use the density of code to their advantage.
\section*{Extensions of ROP}
ROP as a programming technique is already growing in depth and breadth. The most basic extension to ROP is to create the gadgets and a derived program in an automated manner. First an attacker could create, or accquire, a method to generate gadgets from a given executable. From this an attacker could then wirte a program in their language of choice and compile it into an attack package from the gadgets generated.\newline
Another, obvious once someone smart figures it out first, extension is Jump Oriented Programming (JOP). This way instead of using rets and the stack pointer to move through attack code jmp instructions are used. Attacks using this method have more variety simply from the basis that there is more variety in jmp instructions; far, near, direct, and indirect. Using jmp instructions does cause an issue however, they are not as readily available in standard libraries as ret instructions and therefore it is harder to construct a turing complete set of gadgets and from there a viable JOP attack payload.\newline
A would be attacker can also use ROP but not from a standard library linked with an executable, but an executable itself. Large professional applications contain dense code sets that can be exploited in, almost, the same fashion as libc. However, these applications do not normally have the depth of standard library calls and therefore might not to use some gadgets created from libraries to be fully turing complete. This type of attack is a useful extension of ROP since it might be feasible to prevent an attacker from using a standard library in but without complete control flow graphs it would be very difficult to prevent a program from executing code within its own executable for an attack.
\section*{Conclusion}
ROP is a robust and elegant attack pattern that is difficult to defend against. Standard mitigation techniques that amount to write clean, simple and well tested code are the still best. ROP specific mitigation techniques can be side stepped by ROP extensions such as JOP which is just more reason for continued research in the field.
\end{document}
