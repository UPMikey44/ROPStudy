\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{enumerate}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\setlength{\parindent}{0pt}  

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\footnotesize \parbox{11cm}{CIS 551 Homework No. 3 Part 3} }
\rhead{\footnotesize \parbox{11cm}{ } }

\title{Return Oriented Programming Survey}
\author{Michael Patrick O'Connor, Johnathan Michael Smith}
\date{}

\begin{document}
\maketitle

\newpage
\section*{Introduction}
This paper will review, in part, the history of Return Oriented Programming (ROP).  It will explore some technical reasons that made ROP a viable attack methodology. This paper will also explore the foundational elements of ROP, and the ways those foundational elements are used to attack vulnerable systems.  After the review of ROP we will review ROP mitigation techniques.  From ISA mitigation techniques, to mitigation techniques deployed in programming languages. This paper will then take a look at some current extensions to ROP, such as Jump Oriented Programming (JOP), and look at possible ways they can be used in the future.
\section*{History of ROP}
\subsection*{Stack Smashing Mitigation Work Arounds}
From the classic stack smashing attack, obligatory Aleph One reference, of placing attack code to be executed in memory came a technique called Write XOR Execute, $W \oplus X$. This protection prevents any code not marked as executable to the operating system from being executed, so any code to be executed in the memory section would fail. A way around this technique would be to execute code that was already created and marked as executable, this became the basis for Return to Libc attacks.
\subsection*{Return to Libc}
Return to Libc is a class of attack that use stack smashing techniques to overwrite the stack pointer other values and to have arbritary functions from libc, or any viable library. Since the code in a standard library is marked as executable from the OS if an attacker moves control of an attacked program to it it will execute. In this way an attacker could perform any library function available to the attacked program. After performing one library function an attacker can then jump to an other function to perform a set of commands.
\subsection*{Return Oriented Programming}
From return-into-libc attacks there is the generalization of the attack termed Return Oriented Programming (ROP).  This generalized form of return-into-libc attacks is based on the idea of gadgets.  Gadgets are small pieces of code that perform an actiivty, i.e. addition, memory store, etc., and end with a return statement.  The goal of the gadgets is to create a turing complete set of activities that can then be used to perform arbriratrary execution and allow an attacker more freedom than would be provided by return-into-libc attacks.
\section*{Description of ROP}
The difference between ROP and a standard control flow attack is that the stack pointer is used to move from one code segment to the next as opposed to the standard instruction pointer.  In ROP the idea is to use code segments that end in a ret statement
The basis for these code segments are genearlly referred to as gadgets, and all end in return instructions (hence Return Oriented Programming).  These gadgets are generally constructed from a library, either by hand or "compiler," to provide a turning complete set of actions. For this a general principal is to construct a gadget suite of mathmatical and logical operations, set and get from memory, branch, and compare actions.  From this set an attacker can create arbrirtary code execution for a ROP attack and get more functionality than from standard return-into-libc attacks.
\section*{Mitigation Techniques for ROP}
There a number of mitigation tecniques from the hardware upto the software level.  This paper will take a brief look at hardware, operating system, and code design techniques that can help mitigate ROP attacks.  It will also look at the pluses and minuses of these techniques.
\subsection*{Hardware}
At the hardware level Instruction Set Architecture (ISA) randomization would a very effective way to prevent ROP attacks.  ROP attacks rely on jumping into exact portions of a library and expecting that [ASSEMBLY CODE] will execute a given gadget.  If the ISA did not perform the same action with the same assembly code fragments then ROP attacks would become much harder.  An attacker would either need to make an attack code for each randomization of a given ISA and bombard it with a vulnerable program with each variation or an attacker would need to hope that the one version created would work.  ISA randomization would mean reworking of many levels of the computer stack and would need to be pushed across all the systems to be affective. this makes it very difficult to envision being used in the real world.
\subsection*{Operating System}
control flow graphs
others from the papers
\subsection*{Code Design}
prevent buffer overflows
\section*{Extensions of ROP}
Automated ROP compilation
Jump Oriented Programming (JOP)
Use ROP/JOP form a program, say Mozilla Firefox, instead of Libc
\section*{Conclusion}
ROP is a robust way to attack a system
It is not easily stoppable and is easily extensible
It is growing even today
\end{document}
